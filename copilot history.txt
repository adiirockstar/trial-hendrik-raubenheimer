Create a simple RAG agent built off Gemini's API, and that uses data in /Input (With 'from google import genai' already typed out)

import os
import glob
import PyPDF2

# Load and concatenate text from all PDFs in ./Input
def load_pdfs(input_dir="./Input"):
    text = ""
    for pdf_file in glob.glob(os.path.join(input_dir, "*.pdf")):
        with open(pdf_file, "rb") as f:
            reader = PyPDF2.PdfReader(f)
            for page in reader.pages:
                text += page.extract_text() or ""
    return text

# Minimal RAG: retrieve context and ask Gemini
def ask_gemini(query, context):
    prompt = f"Context:\n{context}\n\nQuestion: {query}\nAnswer:"
    response = genai.generate_content(prompt)
    return response.text

if __name__ == "__main__":
    context = load_pdfs()
    user_query = input("Ask a question: ")
    answer = ask_gemini(user_query, context)
    print("Gemini:", answer)
    
Instead of sending through the text of these pdfs to Gemini, send through the pdfs themselves

import os
import glob
import PyPDF2

# Load all PDF file paths from ./Input
def load_pdf_paths(input_dir="./Input"):
    return glob.glob(os.path.join(input_dir, "*.pdf"))

# Minimal RAG: send PDFs as files to Gemini (if supported)
def ask_gemini_with_files(query, pdf_paths):
    # genai.generate_content supports file input via the 'files' parameter
    # This assumes the API and SDK support file uploads
    files = []
    for path in pdf_paths:
        files.append({"file_path": path, "mime_type": "application/pdf"})
    prompt = f"Question: {query}\nPlease answer using the attached PDFs."
    response = genai.generate_content(prompt, files=files)
    return response.text

if __name__ == "__main__":
    pdf_paths = load_pdf_paths()
    user_query = input("Ask a question: ")
    answer = ask_gemini_with_files(user_query, pdf_paths)
    print("Gemini:", answer)

In python, how can I read in a pdf in bytes
    
In Python, you can read a PDF file in bytes by opening it with the "rb" (read-binary) mode:

with open("path/to/file.pdf", "rb") as f:
    pdf_bytes = f.read()

This will load the entire PDF file into the variable pdf_bytes as a bytes object. You can then use this bytes object with libraries like PyPDF2, pdfplumber, or send it over a network, etc.

Convert this to a Streamlit app

from google import genai
import os
import glob
import streamlit as st

def load_pdfs(input_dir="./Input"):
    data = []
    for pdf_file in glob.glob(os.path.join(input_dir, "*.pdf")):
        with open(pdf_file, "rb") as f:
            pdf_bytes = f.read()
            data.append(pdf_bytes)
    return data

st.title("PDF Content Summarizer")

if st.button("Analyze PDFs", type="primary"):
    with st.spinner("Processing PDFs..."):
        client = genai.Client()
        chat = client.chats.create(model="gemini-2.5-flash")
        pdf_data = load_pdfs()

        for pdf_bytes in pdf_data:
            chat.send_message(genai.types.Part.from_bytes(
                data=pdf_bytes,
                mime_type='application/pdf'
            ))
        response = chat.send_message("What is the content of these PDFs?")
        st.subheader("Gemini Response:")
        st.write(response.text)

Why does my spinner load again after I click the button

if 'pdfs_loaded' not in st.session_state:
    with st.spinner("Loading PDFs..."):
        pdf_data = load_pdfs()
        
        for pdf_bytes in pdf_data:
            chat.send_message(genai.types.Part.from_bytes(
                data=pdf_bytes,
                mime_type='application/pdf'
            ))
        
        st.session_state.pdfs_loaded = True

if st.button("Analyze PDFs", type="primary"):
    with st.spinner("Analyzing..."):
        response = chat.send_message("What is the content of these PDFs?")
        st.subheader("Gemini Response:")
        st.write(response.text)

replace this With a textpane that sends messages to Gemini, and Writes the responses

# Load PDFs only once
if 'pdfs_loaded' not in st.session_state:
    with st.spinner("Loading PDFs..."):
        pdf_data = load_pdfs()
        
        for pdf_bytes in pdf_data:
            chat.send_message(genai.types.Part.from_bytes(
                data=pdf_bytes,
                mime_type='application/pdf'
            ))
        
        st.session_state.pdfs_loaded = True

user_input = st.text_area("Ask Gemini about the PDFs:", key="user_input")

if st.button("Send", type="primary") and user_input.strip():
    with st.spinner("Gemini is thinking..."):
        response = chat.send_message(user_input)
        st.subheader("Gemini Response:")
        st.write(response.text)

HoW come Gemini doesn't retain memory on the pdfs

# Initialize chat session only once
if 'chat' not in st.session_state:
    # Initialize your model and chat here
    model = genai.GenerativeModel('gemini-1.5-pro')  # or whatever model you're using
    st.session_state.chat = model.start_chat()

# Use the persistent chat from session state
chat = st.session_state.chat

Add a selectbox that prints to console whenever an option is selected

# Optional selectbox for debugging/testing
st.sidebar.header("ðŸ”§ Debug Options")
debug_options = [
    "None",
    "Show Chat History",
    "Show Session State",
    "Show File List",
    "Test Connection",
    "Clear Memory"
]

selected_option = st.sidebar.selectbox(
    "Select Debug Action:",
    options=debug_options,
    index=0,
    help="Choose an option to execute debug actions"
)

# Handle selectbox selection and print to terminal
if selected_option != "None":
    print(f"[DEBUG] Selected option: {selected_option}")
    
    if selected_option == "Show Chat History":
        print(f"[DEBUG] Chat session state: {hasattr(st.session_state, 'chat')}")
    elif selected_option == "Show Session State":
        print(f"[DEBUG] Session state keys: {list(st.session_state.keys())}")
    elif selected_option == "Show File List":
        files = glob.glob("./Input/*")
        print(f"[DEBUG] Files in Input directory: {files}")
    elif selected_option == "Test Connection":
        print(f"[DEBUG] Testing Gemini connection...")
    elif selected_option == "Clear Memory":
        print(f"[DEBUG] Memory cleared (simulated)")